{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pychrony","text":"<p>Python bindings for libchrony - read-only monitoring of chronyd NTP daemon.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pychrony\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from pychrony import ChronyConnection\n\nwith ChronyConnection() as conn:\n    status = conn.get_tracking()\n    print(f\"Offset: {status.offset:.6f} seconds\")\n    print(f\"Stratum: {status.stratum}\")\n    if status.is_synchronized():\n        print(f\"Synchronized to {status.reference_id_name}\")\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Read-only monitoring: Query chronyd status without modification capabilities</li> <li>Full type hints: Complete type annotations for IDE support</li> <li>Pythonic API: Native Python data structures and context managers</li> <li>Multiple reports: Access tracking, sources, source stats, and RTC data</li> </ul>"},{"location":"#multiple-queries-connection-reuse","title":"Multiple Queries (Connection Reuse)","text":"<p>Use a single connection for multiple queries to minimize overhead:</p> <pre><code>from pychrony import ChronyConnection\n\nwith ChronyConnection() as conn:\n    tracking = conn.get_tracking()\n    sources = conn.get_sources()\n    stats = conn.get_source_stats()\n    rtc = conn.get_rtc_data()\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<p>pychrony provides typed exceptions for different error conditions:</p> <pre><code>from pychrony import (\n    ChronyConnection,\n    ChronyError,\n    ChronyLibraryError,\n    ChronyConnectionError,\n    ChronyPermissionError,\n)\n\ntry:\n    with ChronyConnection() as conn:\n        status = conn.get_tracking()\nexcept ChronyLibraryError:\n    print(\"libchrony not installed\")\nexcept ChronyConnectionError:\n    print(\"chronyd not running\")\nexcept ChronyPermissionError:\n    print(\"Permission denied - add user to chrony group\")\n</code></pre>"},{"location":"#remote-and-custom-connections","title":"Remote and Custom Connections","text":"<p>Connect to a custom Unix socket path:</p> <pre><code>with ChronyConnection(\"/custom/path/chronyd.sock\") as conn:\n    status = conn.get_tracking()\n</code></pre> <p>Connect to a remote chronyd instance via UDP:</p> <pre><code>with ChronyConnection(\"192.168.1.100\") as conn:\n    status = conn.get_tracking()\n</code></pre>"},{"location":"#thread-safety","title":"Thread Safety","text":"<p><code>ChronyConnection</code> is NOT thread-safe. The underlying libchrony session maintains stateful request/response cycles that cannot be safely shared between threads.</p> <p>For multi-threaded applications, use one of these patterns:</p> <p>Connection per thread (simplest):</p> <pre><code>def worker():\n    with ChronyConnection() as conn:\n        return conn.get_tracking()\n</code></pre> <p>Thread-local storage (for connection reuse):</p> <pre><code>import threading\n\n_local = threading.local()\n\ndef get_tracking():\n    if not hasattr(_local, 'conn'):\n        _local.conn = ChronyConnection()\n    with _local.conn as conn:\n        return conn.get_tracking()\n</code></pre> <p>The returned dataclasses (<code>TrackingStatus</code>, <code>Source</code>, etc.) are frozen and immutable, so they can be safely shared across threads after retrieval.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>API Reference - Complete API documentation</li> <li>GitHub Repository - Source code and issues</li> <li>PyPI Package - Installation</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.10+</li> <li>libchrony (system library)</li> <li>Linux (primary platform)</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for pychrony, auto-generated from source code docstrings.</p>"},{"location":"api/#connection","title":"Connection","text":"<p>The main entry point for interacting with chronyd.</p>"},{"location":"api/#pychrony.ChronyConnection","title":"<code>ChronyConnection</code>","text":"<p>Context manager for chrony connections.</p> <p>Provides connection reuse for multiple queries to chronyd within a single context, properly managing socket and session lifecycle.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str | None</code> <p>Connection address. Supports:</p> <ul> <li>Unix socket path: <code>\"/run/chrony/chronyd.sock\"</code></li> <li>IPv4: <code>\"192.168.1.1\"</code> or <code>\"192.168.1.1:323\"</code></li> <li>IPv6: <code>\"2001:db8::1\"</code> or <code>\"[2001:db8::1]:323\"</code></li> <li><code>None</code>: Auto-detect (tries Unix socket paths, then localhost)</li> </ul> <code>None</code> <p>Methods:</p> Name Description <code>get_tracking</code> <p>Get current NTP tracking status (returns <code>TrackingStatus</code>).</p> <code>get_sources</code> <p>Get configured time sources (returns <code>list[Source]</code>).</p> <code>get_source_stats</code> <p>Get source statistics (returns <code>list[SourceStats]</code>).</p> <code>get_rtc_data</code> <p>Get RTC tracking data (returns <code>RTCData</code> or <code>None</code>).</p> Thread Safety <p>NOT thread-safe. Each thread needs its own connection.</p> See Also <p><code>TrackingStatus</code>: Tracking data model. <code>Source</code>: Time source data model. <code>SourceStats</code>: Source statistics data model. <code>RTCData</code>: RTC tracking data model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     tracking = conn.get_tracking()\n...     sources = conn.get_sources()\n...     stats = conn.get_source_stats()\n...     rtc = conn.get_rtc_data()\n</code></pre> Source code in <code>src/pychrony/_core/_bindings.py</code> <pre><code>class ChronyConnection:\n    \"\"\"Context manager for chrony connections.\n\n    Provides connection reuse for multiple queries to chronyd within a single\n    context, properly managing socket and session lifecycle.\n\n    Args:\n        address: Connection address. Supports:\n\n            - Unix socket path: ``\"/run/chrony/chronyd.sock\"``\n            - IPv4: ``\"192.168.1.1\"`` or ``\"192.168.1.1:323\"``\n            - IPv6: ``\"2001:db8::1\"`` or ``\"[2001:db8::1]:323\"``\n            - ``None``: Auto-detect (tries Unix socket paths, then localhost)\n\n    Methods:\n        get_tracking: Get current NTP tracking status (returns `TrackingStatus`).\n        get_sources: Get configured time sources (returns ``list[Source]``).\n        get_source_stats: Get source statistics (returns ``list[SourceStats]``).\n        get_rtc_data: Get RTC tracking data (returns `RTCData` or ``None``).\n\n    Thread Safety:\n        NOT thread-safe. Each thread needs its own connection.\n\n    See Also:\n        `TrackingStatus`: Tracking data model.\n        `Source`: Time source data model.\n        `SourceStats`: Source statistics data model.\n        `RTCData`: RTC tracking data model.\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     tracking = conn.get_tracking()\n        ...     sources = conn.get_sources()\n        ...     stats = conn.get_source_stats()\n        ...     rtc = conn.get_rtc_data()\n    \"\"\"\n\n    def __init__(self, address: str | None = None) -&gt; None:\n        \"\"\"Initialize ChronyConnection with optional address.\n\n        Args:\n            address: Connection address (see class docstring for formats)\n        \"\"\"\n        self._address = address\n        self._fd: int | None = None\n        self._session: Any = None\n        self._session_ptr: Any = None\n        self._in_context = False\n\n    def __enter__(self) -&gt; \"ChronyConnection\":\n        \"\"\"Enter context manager, opening connection to chronyd.\"\"\"\n        _check_library_available()\n        self._open()\n        self._in_context = True\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit context manager, closing connection to chronyd.\"\"\"\n        self._in_context = False\n        self._close()\n\n    def _resolve_address(self) -&gt; bytes | None:\n        \"\"\"Resolve the address to use for connection.\n\n        Returns:\n            Encoded address bytes, or None for auto-detect\n\n        Raises:\n            ChronyConnectionError: If no socket path found during auto-detect\n        \"\"\"\n        if self._address is not None:\n            return self._address.encode()\n\n        # Auto-detect: try default Unix socket paths\n        for path in DEFAULT_SOCKET_PATHS:\n            if os.path.exists(path):\n                return path.encode()\n\n        # No Unix socket found - pass NULL to let libchrony try localhost\n        return None\n\n    def _open(self) -&gt; None:\n        \"\"\"Open socket connection and initialize session.\n\n        Raises:\n            ChronyConnectionError: If connection fails\n            ChronyPermissionError: If permission denied\n        \"\"\"\n        address_bytes = self._resolve_address()\n\n        # Open socket connection\n        if address_bytes is not None:\n            self._fd = _lib.chrony_open_socket(address_bytes)\n        else:\n            self._fd = _lib.chrony_open_socket(_ffi.NULL)\n\n        if self._fd &lt; 0:\n            # Check for permission issues\n            if self._fd == -errno.EACCES or (\n                self._address is not None\n                and os.path.exists(self._address)\n                and not os.access(self._address, os.R_OK | os.W_OK)\n            ):\n                raise ChronyPermissionError(\n                    f\"Permission denied accessing {self._address or 'chronyd'}. \"\n                    \"Run as root or add user to chrony group.\",\n                    error_code=self._fd,\n                )\n            address_desc = self._address or \"chronyd (auto-detect)\"\n            raise ChronyConnectionError(\n                f\"Failed to connect to {address_desc}. Is chronyd running?\",\n                error_code=self._fd,\n            )\n\n        # Initialize session\n        self._session_ptr = _ffi.new(\"chrony_session **\")\n        err = _lib.chrony_init_session(self._session_ptr, self._fd)\n        if err != 0:\n            # Clean up socket on failure\n            _lib.chrony_close_socket(self._fd)\n            self._fd = None\n            raise ChronyConnectionError(\n                \"Failed to initialize chrony session\",\n                error_code=err,\n            )\n\n        self._session = self._session_ptr[0]\n\n    def _close(self) -&gt; None:\n        \"\"\"Close session and socket connection.\"\"\"\n        if self._session is not None and self._session != _ffi.NULL:\n            _lib.chrony_deinit_session(self._session)\n            self._session = None\n\n        if self._fd is not None and self._fd &gt;= 0:\n            _lib.chrony_close_socket(self._fd)\n            self._fd = None\n\n        self._session_ptr = None\n\n    def _ensure_context(self) -&gt; None:\n        \"\"\"Ensure we're within a context manager.\n\n        Raises:\n            RuntimeError: If called outside context manager\n        \"\"\"\n        if not self._in_context:\n            raise RuntimeError(\n                \"ChronyConnection methods must be called within a 'with' block\"\n            )\n\n    def _request_report(self, report_name: bytes) -&gt; int:\n        \"\"\"Request number of records for a report type.\n\n        Args:\n            report_name: Report name (e.g., b\"tracking\", b\"sources\")\n\n        Returns:\n            Number of records available\n\n        Raises:\n            ChronyDataError: If request fails\n        \"\"\"\n        err = _lib.chrony_request_report_number_records(self._session, report_name)\n        if err != 0:\n            raise ChronyDataError(\n                f\"Failed to request {report_name.decode()} report\",\n                error_code=err,\n            )\n\n        while _lib.chrony_needs_response(self._session):\n            err = _lib.chrony_process_response(self._session)\n            if err != 0:\n                raise ChronyDataError(\n                    f\"Failed to process {report_name.decode()} response\",\n                    error_code=err,\n                )\n\n        return _lib.chrony_get_report_number_records(self._session)\n\n    def _request_record(self, report_name: bytes, index: int) -&gt; None:\n        \"\"\"Request a specific record from a report.\n\n        Args:\n            report_name: Report name (e.g., b\"tracking\", b\"sources\")\n            index: Record index\n\n        Raises:\n            ChronyDataError: If request fails\n        \"\"\"\n        err = _lib.chrony_request_record(self._session, report_name, index)\n        if err != 0:\n            raise ChronyDataError(\n                f\"Failed to request {report_name.decode()} record {index}\",\n                error_code=err,\n            )\n\n        while _lib.chrony_needs_response(self._session):\n            err = _lib.chrony_process_response(self._session)\n            if err != 0:\n                raise ChronyDataError(\n                    f\"Failed to process {report_name.decode()} record {index}\",\n                    error_code=err,\n                )\n\n    def get_tracking(self) -&gt; TrackingStatus:\n        \"\"\"Get current tracking status from chronyd.\n\n        Returns:\n            TrackingStatus: Current tracking information from chronyd.\n\n        Raises:\n            RuntimeError: If called outside context manager\n            ChronyDataError: If tracking data is invalid or incomplete.\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     status = conn.get_tracking()\n            ...     print(f\"Offset: {status.offset:.6f} seconds\")\n        \"\"\"\n        self._ensure_context()\n\n        num_records = self._request_report(b\"tracking\")\n        if num_records &lt; 1:\n            raise ChronyDataError(\"No tracking records available\")\n\n        self._request_record(b\"tracking\", 0)\n\n        # Extract fields\n        ref_id = _get_uinteger_field(self._session, \"reference ID\")\n        leap_status_int = _get_uinteger_field(self._session, \"leap status\")\n\n        try:\n            leap_status = LeapStatus(leap_status_int)\n        except ValueError:\n            raise ChronyDataError(\n                f\"Unknown leap_status value {leap_status_int}. \"\n                \"This may indicate a newer chrony version - please update pychrony.\"\n            )\n\n        data = {\n            \"reference_id\": ref_id,\n            \"reference_id_name\": _ref_id_to_name(ref_id),\n            \"reference_ip\": _get_string_field(self._session, \"address\"),\n            \"stratum\": _get_uinteger_field(self._session, \"stratum\"),\n            \"leap_status\": leap_status,\n            \"ref_time\": _get_timespec_field(self._session, \"reference time\"),\n            \"offset\": _get_float_field(self._session, \"current correction\"),\n            \"last_offset\": _get_float_field(self._session, \"last offset\"),\n            \"rms_offset\": _get_float_field(self._session, \"RMS offset\"),\n            \"frequency\": _get_float_field(self._session, \"frequency offset\"),\n            \"residual_freq\": _get_float_field(self._session, \"residual frequency\"),\n            \"skew\": _get_float_field(self._session, \"skew\"),\n            \"root_delay\": _get_float_field(self._session, \"root delay\"),\n            \"root_dispersion\": _get_float_field(self._session, \"root dispersion\"),\n            \"update_interval\": _get_float_field(self._session, \"last update interval\"),\n        }\n\n        # Validate\n        self._validate_tracking(data)\n\n        return TrackingStatus(**data)\n\n    def _validate_tracking(self, data: dict) -&gt; None:\n        \"\"\"Validate tracking data before creating TrackingStatus.\"\"\"\n        if not 0 &lt;= data[\"stratum\"] &lt;= 15:\n            raise ChronyDataError(f\"Invalid stratum: {data['stratum']}\")\n\n        float_fields = [\n            \"ref_time\",\n            \"offset\",\n            \"last_offset\",\n            \"rms_offset\",\n            \"frequency\",\n            \"residual_freq\",\n            \"skew\",\n            \"root_delay\",\n            \"root_dispersion\",\n            \"update_interval\",\n        ]\n        for field in float_fields:\n            if math.isnan(data[field]) or math.isinf(data[field]):\n                raise ChronyDataError(f\"Invalid {field}: {data[field]}\")\n\n        non_negative = [\n            \"ref_time\",\n            \"rms_offset\",\n            \"skew\",\n            \"root_delay\",\n            \"root_dispersion\",\n            \"update_interval\",\n        ]\n        for field in non_negative:\n            if data[field] &lt; 0:\n                raise ChronyDataError(f\"{field} must be non-negative: {data[field]}\")\n\n    def get_sources(self) -&gt; list[Source]:\n        \"\"\"Get all configured time sources from chronyd.\n\n        Returns:\n            list[Source]: List of Source objects for each configured source.\n                Empty list if no sources are configured.\n\n        Raises:\n            RuntimeError: If called outside context manager\n            ChronyDataError: If source data is invalid or incomplete.\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     sources = conn.get_sources()\n            ...     for src in sources:\n            ...         print(f\"{src.address}: stratum {src.stratum}\")\n        \"\"\"\n        self._ensure_context()\n\n        num_records = self._request_report(b\"sources\")\n        if num_records &lt; 1:\n            return []\n\n        sources = []\n        for i in range(num_records):\n            self._request_record(b\"sources\", i)\n            data = self._extract_source()\n            self._validate_source(data)\n            sources.append(Source(**data))\n\n        return sources\n\n    def _extract_source(self) -&gt; dict:\n        \"\"\"Extract source fields from the current session record.\"\"\"\n        state_int = _get_uinteger_field(self._session, \"state\")\n        mode_int = _get_uinteger_field(self._session, \"mode\")\n\n        try:\n            state = SourceState(state_int)\n        except ValueError:\n            raise ChronyDataError(\n                f\"Unknown state value {state_int}. \"\n                \"This may indicate a newer chrony version - please update pychrony.\"\n            )\n\n        try:\n            mode = SourceMode(mode_int)\n        except ValueError:\n            raise ChronyDataError(\n                f\"Unknown mode value {mode_int}. \"\n                \"This may indicate a newer chrony version - please update pychrony.\"\n            )\n\n        # In libchrony 0.2, sources report uses TYPE_ADDRESS_OR_UINT32_IN_ADDRESS\n        # which exposes either \"address\" (NTP sources) or \"reference ID\" (refclocks).\n        # We check mode to determine which field to fetch.\n        if mode == SourceMode.REFCLOCK:\n            ref_id = _get_uinteger_field(self._session, \"reference ID\")\n            address = _ref_id_to_name(ref_id)\n        else:\n            address = _get_string_field(self._session, \"address\")\n\n        return {\n            \"address\": address,\n            \"poll\": _get_integer_field(self._session, \"poll\"),\n            \"stratum\": _get_uinteger_field(self._session, \"stratum\"),\n            \"state\": state,\n            \"mode\": mode,\n            \"flags\": _get_uinteger_field(self._session, \"flags\"),\n            \"reachability\": _get_uinteger_field(self._session, \"reachability\"),\n            \"last_sample_ago\": _get_uinteger_field(self._session, \"last sample ago\"),\n            \"orig_latest_meas\": _get_float_field(\n                self._session, \"original last sample offset\"\n            ),\n            \"latest_meas\": _get_float_field(\n                self._session, \"adjusted last sample offset\"\n            ),\n            \"latest_meas_err\": _get_float_field(self._session, \"last sample error\"),\n        }\n\n    def _validate_source(self, data: dict) -&gt; None:\n        \"\"\"Validate source data before creating Source.\"\"\"\n        _validate_bounded_int(data[\"stratum\"], \"stratum\", 0, 15)\n        _validate_bounded_int(data[\"reachability\"], \"reachability\", 0, 255)\n        _validate_non_negative_int(data[\"last_sample_ago\"], \"last_sample_ago\")\n\n        for field in [\"orig_latest_meas\", \"latest_meas\", \"latest_meas_err\"]:\n            _validate_finite_float(data[field], field)\n\n        if data[\"latest_meas_err\"] &lt; 0:\n            raise ChronyDataError(\n                f\"latest_meas_err must be non-negative: {data['latest_meas_err']}\"\n            )\n\n    def get_source_stats(self) -&gt; list[SourceStats]:\n        \"\"\"Get statistical data for all time sources from chronyd.\n\n        Returns:\n            list[SourceStats]: List of SourceStats objects for each source.\n                Empty list if no sources are configured.\n\n        Raises:\n            RuntimeError: If called outside context manager\n            ChronyDataError: If statistics data is invalid or incomplete.\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     stats = conn.get_source_stats()\n            ...     for s in stats:\n            ...         print(f\"{s.address}: {s.samples} samples\")\n        \"\"\"\n        self._ensure_context()\n\n        num_records = self._request_report(b\"sourcestats\")\n        if num_records &lt; 1:\n            return []\n\n        stats = []\n        for i in range(num_records):\n            self._request_record(b\"sourcestats\", i)\n            data = self._extract_sourcestats()\n            self._validate_sourcestats(data)\n            stats.append(SourceStats(**data))\n\n        return stats\n\n    def _extract_sourcestats(self) -&gt; dict:\n        \"\"\"Extract sourcestats fields from the current session record.\"\"\"\n        return {\n            \"reference_id\": _get_uinteger_field(self._session, \"reference ID\"),\n            \"address\": _get_string_field(self._session, \"address\"),\n            \"samples\": _get_uinteger_field(self._session, \"samples\"),\n            \"runs\": _get_uinteger_field(self._session, \"runs\"),\n            \"span\": _get_uinteger_field(self._session, \"span\"),\n            \"std_dev\": _get_float_field(self._session, \"standard deviation\"),\n            \"resid_freq\": _get_float_field(self._session, \"residual frequency\"),\n            \"skew\": _get_float_field(self._session, \"skew\"),\n            \"offset\": _get_float_field(self._session, \"offset\"),\n            \"offset_err\": _get_float_field(self._session, \"offset error\"),\n        }\n\n    def _validate_sourcestats(self, data: dict) -&gt; None:\n        \"\"\"Validate sourcestats data before creating SourceStats.\"\"\"\n        _validate_non_negative_int(data[\"samples\"], \"samples\")\n        _validate_non_negative_int(data[\"runs\"], \"runs\")\n        _validate_non_negative_int(data[\"span\"], \"span\")\n\n        for field in [\"std_dev\", \"resid_freq\", \"skew\", \"offset\", \"offset_err\"]:\n            _validate_finite_float(data[field], field)\n\n        if data[\"std_dev\"] &lt; 0:\n            raise ChronyDataError(f\"std_dev must be non-negative: {data['std_dev']}\")\n        if data[\"skew\"] &lt; 0:\n            raise ChronyDataError(f\"skew must be non-negative: {data['skew']}\")\n        if data[\"offset_err\"] &lt; 0:\n            raise ChronyDataError(\n                f\"offset_err must be non-negative: {data['offset_err']}\"\n            )\n\n    def get_rtc_data(self) -&gt; RTCData | None:\n        \"\"\"Get Real-Time Clock tracking data from chronyd.\n\n        Returns:\n            RTCData if RTC tracking is enabled, None otherwise.\n\n        Raises:\n            RuntimeError: If called outside context manager\n            ChronyDataError: If RTC data is invalid or malformed.\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     rtc = conn.get_rtc_data()\n            ...     if rtc:\n            ...         print(f\"RTC offset: {rtc.offset:.6f}s\")\n        \"\"\"\n        self._ensure_context()\n\n        num_records = self._request_report(b\"rtcdata\")\n        if num_records &lt; 1:\n            return None\n\n        # Try to fetch rtcdata record - may fail if RTC not actually configured\n        try:\n            err = _lib.chrony_request_record(self._session, b\"rtcdata\", 0)\n            if err != 0:\n                return None\n\n            while _lib.chrony_needs_response(self._session):\n                err = _lib.chrony_process_response(self._session)\n                if err != 0:\n                    return None\n        except Exception:\n            return None\n\n        data = self._extract_rtc()\n        self._validate_rtc(data)\n\n        return RTCData(**data)\n\n    def _extract_rtc(self) -&gt; dict:\n        \"\"\"Extract RTC fields from the current session record.\"\"\"\n        return {\n            \"ref_time\": _get_timespec_field(self._session, \"reference time\"),\n            \"samples\": _get_uinteger_field(self._session, \"samples\"),\n            \"runs\": _get_uinteger_field(self._session, \"runs\"),\n            \"span\": _get_uinteger_field(self._session, \"span\"),\n            \"offset\": _get_float_field(self._session, \"offset\"),\n            \"freq_offset\": _get_float_field(self._session, \"frequency offset\"),\n        }\n\n    def _validate_rtc(self, data: dict) -&gt; None:\n        \"\"\"Validate RTC data before creating RTCData.\"\"\"\n        _validate_non_negative_int(data[\"samples\"], \"samples\")\n        _validate_non_negative_int(data[\"runs\"], \"runs\")\n        _validate_non_negative_int(data[\"span\"], \"span\")\n\n        for field in [\"ref_time\", \"offset\", \"freq_offset\"]:\n            _validate_finite_float(data[field], field)\n\n        if data[\"ref_time\"] &lt; 0:\n            raise ChronyDataError(f\"ref_time must be non-negative: {data['ref_time']}\")\n</code></pre>"},{"location":"api/#pychrony.ChronyConnection.__init__","title":"<code>__init__(address=None)</code>","text":"<p>Initialize ChronyConnection with optional address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str | None</code> <p>Connection address (see class docstring for formats)</p> <code>None</code> Source code in <code>src/pychrony/_core/_bindings.py</code> <pre><code>def __init__(self, address: str | None = None) -&gt; None:\n    \"\"\"Initialize ChronyConnection with optional address.\n\n    Args:\n        address: Connection address (see class docstring for formats)\n    \"\"\"\n    self._address = address\n    self._fd: int | None = None\n    self._session: Any = None\n    self._session_ptr: Any = None\n    self._in_context = False\n</code></pre>"},{"location":"api/#pychrony.ChronyConnection.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter context manager, opening connection to chronyd.</p> Source code in <code>src/pychrony/_core/_bindings.py</code> <pre><code>def __enter__(self) -&gt; \"ChronyConnection\":\n    \"\"\"Enter context manager, opening connection to chronyd.\"\"\"\n    _check_library_available()\n    self._open()\n    self._in_context = True\n    return self\n</code></pre>"},{"location":"api/#pychrony.ChronyConnection.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit context manager, closing connection to chronyd.</p> Source code in <code>src/pychrony/_core/_bindings.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit context manager, closing connection to chronyd.\"\"\"\n    self._in_context = False\n    self._close()\n</code></pre>"},{"location":"api/#pychrony.ChronyConnection.get_tracking","title":"<code>get_tracking()</code>","text":"<p>Get current tracking status from chronyd.</p> <p>Returns:</p> Name Type Description <code>TrackingStatus</code> <code>TrackingStatus</code> <p>Current tracking information from chronyd.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called outside context manager</p> <code>ChronyDataError</code> <p>If tracking data is invalid or incomplete.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     status = conn.get_tracking()\n...     print(f\"Offset: {status.offset:.6f} seconds\")\n</code></pre> Source code in <code>src/pychrony/_core/_bindings.py</code> <pre><code>def get_tracking(self) -&gt; TrackingStatus:\n    \"\"\"Get current tracking status from chronyd.\n\n    Returns:\n        TrackingStatus: Current tracking information from chronyd.\n\n    Raises:\n        RuntimeError: If called outside context manager\n        ChronyDataError: If tracking data is invalid or incomplete.\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     status = conn.get_tracking()\n        ...     print(f\"Offset: {status.offset:.6f} seconds\")\n    \"\"\"\n    self._ensure_context()\n\n    num_records = self._request_report(b\"tracking\")\n    if num_records &lt; 1:\n        raise ChronyDataError(\"No tracking records available\")\n\n    self._request_record(b\"tracking\", 0)\n\n    # Extract fields\n    ref_id = _get_uinteger_field(self._session, \"reference ID\")\n    leap_status_int = _get_uinteger_field(self._session, \"leap status\")\n\n    try:\n        leap_status = LeapStatus(leap_status_int)\n    except ValueError:\n        raise ChronyDataError(\n            f\"Unknown leap_status value {leap_status_int}. \"\n            \"This may indicate a newer chrony version - please update pychrony.\"\n        )\n\n    data = {\n        \"reference_id\": ref_id,\n        \"reference_id_name\": _ref_id_to_name(ref_id),\n        \"reference_ip\": _get_string_field(self._session, \"address\"),\n        \"stratum\": _get_uinteger_field(self._session, \"stratum\"),\n        \"leap_status\": leap_status,\n        \"ref_time\": _get_timespec_field(self._session, \"reference time\"),\n        \"offset\": _get_float_field(self._session, \"current correction\"),\n        \"last_offset\": _get_float_field(self._session, \"last offset\"),\n        \"rms_offset\": _get_float_field(self._session, \"RMS offset\"),\n        \"frequency\": _get_float_field(self._session, \"frequency offset\"),\n        \"residual_freq\": _get_float_field(self._session, \"residual frequency\"),\n        \"skew\": _get_float_field(self._session, \"skew\"),\n        \"root_delay\": _get_float_field(self._session, \"root delay\"),\n        \"root_dispersion\": _get_float_field(self._session, \"root dispersion\"),\n        \"update_interval\": _get_float_field(self._session, \"last update interval\"),\n    }\n\n    # Validate\n    self._validate_tracking(data)\n\n    return TrackingStatus(**data)\n</code></pre>"},{"location":"api/#pychrony.ChronyConnection.get_sources","title":"<code>get_sources()</code>","text":"<p>Get all configured time sources from chronyd.</p> <p>Returns:</p> Type Description <code>list[Source]</code> <p>list[Source]: List of Source objects for each configured source. Empty list if no sources are configured.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called outside context manager</p> <code>ChronyDataError</code> <p>If source data is invalid or incomplete.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     sources = conn.get_sources()\n...     for src in sources:\n...         print(f\"{src.address}: stratum {src.stratum}\")\n</code></pre> Source code in <code>src/pychrony/_core/_bindings.py</code> <pre><code>def get_sources(self) -&gt; list[Source]:\n    \"\"\"Get all configured time sources from chronyd.\n\n    Returns:\n        list[Source]: List of Source objects for each configured source.\n            Empty list if no sources are configured.\n\n    Raises:\n        RuntimeError: If called outside context manager\n        ChronyDataError: If source data is invalid or incomplete.\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     sources = conn.get_sources()\n        ...     for src in sources:\n        ...         print(f\"{src.address}: stratum {src.stratum}\")\n    \"\"\"\n    self._ensure_context()\n\n    num_records = self._request_report(b\"sources\")\n    if num_records &lt; 1:\n        return []\n\n    sources = []\n    for i in range(num_records):\n        self._request_record(b\"sources\", i)\n        data = self._extract_source()\n        self._validate_source(data)\n        sources.append(Source(**data))\n\n    return sources\n</code></pre>"},{"location":"api/#pychrony.ChronyConnection.get_source_stats","title":"<code>get_source_stats()</code>","text":"<p>Get statistical data for all time sources from chronyd.</p> <p>Returns:</p> Type Description <code>list[SourceStats]</code> <p>list[SourceStats]: List of SourceStats objects for each source. Empty list if no sources are configured.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called outside context manager</p> <code>ChronyDataError</code> <p>If statistics data is invalid or incomplete.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     stats = conn.get_source_stats()\n...     for s in stats:\n...         print(f\"{s.address}: {s.samples} samples\")\n</code></pre> Source code in <code>src/pychrony/_core/_bindings.py</code> <pre><code>def get_source_stats(self) -&gt; list[SourceStats]:\n    \"\"\"Get statistical data for all time sources from chronyd.\n\n    Returns:\n        list[SourceStats]: List of SourceStats objects for each source.\n            Empty list if no sources are configured.\n\n    Raises:\n        RuntimeError: If called outside context manager\n        ChronyDataError: If statistics data is invalid or incomplete.\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     stats = conn.get_source_stats()\n        ...     for s in stats:\n        ...         print(f\"{s.address}: {s.samples} samples\")\n    \"\"\"\n    self._ensure_context()\n\n    num_records = self._request_report(b\"sourcestats\")\n    if num_records &lt; 1:\n        return []\n\n    stats = []\n    for i in range(num_records):\n        self._request_record(b\"sourcestats\", i)\n        data = self._extract_sourcestats()\n        self._validate_sourcestats(data)\n        stats.append(SourceStats(**data))\n\n    return stats\n</code></pre>"},{"location":"api/#pychrony.ChronyConnection.get_rtc_data","title":"<code>get_rtc_data()</code>","text":"<p>Get Real-Time Clock tracking data from chronyd.</p> <p>Returns:</p> Type Description <code>RTCData | None</code> <p>RTCData if RTC tracking is enabled, None otherwise.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called outside context manager</p> <code>ChronyDataError</code> <p>If RTC data is invalid or malformed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     rtc = conn.get_rtc_data()\n...     if rtc:\n...         print(f\"RTC offset: {rtc.offset:.6f}s\")\n</code></pre> Source code in <code>src/pychrony/_core/_bindings.py</code> <pre><code>def get_rtc_data(self) -&gt; RTCData | None:\n    \"\"\"Get Real-Time Clock tracking data from chronyd.\n\n    Returns:\n        RTCData if RTC tracking is enabled, None otherwise.\n\n    Raises:\n        RuntimeError: If called outside context manager\n        ChronyDataError: If RTC data is invalid or malformed.\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     rtc = conn.get_rtc_data()\n        ...     if rtc:\n        ...         print(f\"RTC offset: {rtc.offset:.6f}s\")\n    \"\"\"\n    self._ensure_context()\n\n    num_records = self._request_report(b\"rtcdata\")\n    if num_records &lt; 1:\n        return None\n\n    # Try to fetch rtcdata record - may fail if RTC not actually configured\n    try:\n        err = _lib.chrony_request_record(self._session, b\"rtcdata\", 0)\n        if err != 0:\n            return None\n\n        while _lib.chrony_needs_response(self._session):\n            err = _lib.chrony_process_response(self._session)\n            if err != 0:\n                return None\n    except Exception:\n        return None\n\n    data = self._extract_rtc()\n    self._validate_rtc(data)\n\n    return RTCData(**data)\n</code></pre>"},{"location":"api/#data-models","title":"Data Models","text":"<p>Frozen dataclasses representing chronyd report data.</p>"},{"location":"api/#pychrony.TrackingStatus","title":"<code>TrackingStatus</code>  <code>dataclass</code>","text":"<p>Chrony tracking status information.</p> <p>Represents the current time synchronization state from chronyd, including offset, frequency, and accuracy metrics.</p> <p>Attributes:</p> Name Type Description <code>reference_id</code> <code>int</code> <p>NTP reference identifier (uint32 as hex IP or name).</p> <code>reference_id_name</code> <code>str</code> <p>Human-readable reference source name.</p> <code>reference_ip</code> <code>str</code> <p>IP address of reference source (IPv4, IPv6, or ID#).</p> <code>stratum</code> <code>int</code> <p>NTP stratum level (0=reference clock, 1-15=downstream).</p> <code>leap_status</code> <code>LeapStatus</code> <p>Leap second status (see <code>LeapStatus</code>).</p> <code>ref_time</code> <code>float</code> <p>Timestamp of last measurement (seconds since epoch).</p> <code>offset</code> <code>float</code> <p>Current offset from reference (seconds, can be negative).</p> <code>last_offset</code> <code>float</code> <p>Offset at last measurement (seconds).</p> <code>rms_offset</code> <code>float</code> <p>Root mean square of recent offsets (seconds).</p> <code>frequency</code> <code>float</code> <p>Clock frequency error (parts per million).</p> <code>residual_freq</code> <code>float</code> <p>Residual frequency for current source (ppm).</p> <code>skew</code> <code>float</code> <p>Estimated error bound on frequency (ppm).</p> <code>root_delay</code> <code>float</code> <p>Total roundtrip delay to stratum-1 source (seconds).</p> <code>root_dispersion</code> <code>float</code> <p>Total dispersion to reference (seconds).</p> <code>update_interval</code> <code>float</code> <p>Seconds since last successful update.</p> See Also <p><code>LeapStatus</code>: Enum for leap second status values. <code>ChronyConnection.get_tracking</code>: Method to retrieve this data.</p> Source code in <code>src/pychrony/models.py</code> <pre><code>@dataclass(frozen=True)\nclass TrackingStatus:\n    \"\"\"Chrony tracking status information.\n\n    Represents the current time synchronization state from chronyd,\n    including offset, frequency, and accuracy metrics.\n\n    Attributes:\n        reference_id: NTP reference identifier (uint32 as hex IP or name).\n        reference_id_name: Human-readable reference source name.\n        reference_ip: IP address of reference source (IPv4, IPv6, or ID#).\n        stratum: NTP stratum level (0=reference clock, 1-15=downstream).\n        leap_status: Leap second status (see `LeapStatus`).\n        ref_time: Timestamp of last measurement (seconds since epoch).\n        offset: Current offset from reference (seconds, can be negative).\n        last_offset: Offset at last measurement (seconds).\n        rms_offset: Root mean square of recent offsets (seconds).\n        frequency: Clock frequency error (parts per million).\n        residual_freq: Residual frequency for current source (ppm).\n        skew: Estimated error bound on frequency (ppm).\n        root_delay: Total roundtrip delay to stratum-1 source (seconds).\n        root_dispersion: Total dispersion to reference (seconds).\n        update_interval: Seconds since last successful update.\n\n    See Also:\n        `LeapStatus`: Enum for leap second status values.\n        `ChronyConnection.get_tracking`: Method to retrieve this data.\n    \"\"\"\n\n    reference_id: int\n    reference_id_name: str\n    reference_ip: str\n    stratum: int\n    leap_status: LeapStatus\n    ref_time: float\n    offset: float\n    last_offset: float\n    rms_offset: float\n    frequency: float\n    residual_freq: float\n    skew: float\n    root_delay: float\n    root_dispersion: float\n    update_interval: float\n\n    def is_synchronized(self) -&gt; bool:\n        \"\"\"Check if chronyd is synchronized to a source.\n\n        Returns:\n            True if synchronized (reference_id != 0 and stratum &lt; 16),\n            False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     status = conn.get_tracking()\n            ...     if status.is_synchronized():\n            ...         print(f\"Synced to {status.reference_ip}\")\n        \"\"\"\n        return self.reference_id != 0 and self.stratum &lt; 16\n\n    def is_leap_pending(self) -&gt; bool:\n        \"\"\"Check if a leap second adjustment is pending.\n\n        Returns:\n            True if leap_status is INSERT or DELETE,\n            False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     status = conn.get_tracking()\n            ...     if status.is_leap_pending():\n            ...         print(f\"Leap second pending: {status.leap_status.name}\")\n        \"\"\"\n        return self.leap_status in (LeapStatus.INSERT, LeapStatus.DELETE)\n</code></pre>"},{"location":"api/#pychrony.TrackingStatus.is_synchronized","title":"<code>is_synchronized()</code>","text":"<p>Check if chronyd is synchronized to a source.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if synchronized (reference_id != 0 and stratum &lt; 16),</p> <code>bool</code> <p>False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     status = conn.get_tracking()\n...     if status.is_synchronized():\n...         print(f\"Synced to {status.reference_ip}\")\n</code></pre> Source code in <code>src/pychrony/models.py</code> <pre><code>def is_synchronized(self) -&gt; bool:\n    \"\"\"Check if chronyd is synchronized to a source.\n\n    Returns:\n        True if synchronized (reference_id != 0 and stratum &lt; 16),\n        False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     status = conn.get_tracking()\n        ...     if status.is_synchronized():\n        ...         print(f\"Synced to {status.reference_ip}\")\n    \"\"\"\n    return self.reference_id != 0 and self.stratum &lt; 16\n</code></pre>"},{"location":"api/#pychrony.TrackingStatus.is_leap_pending","title":"<code>is_leap_pending()</code>","text":"<p>Check if a leap second adjustment is pending.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if leap_status is INSERT or DELETE,</p> <code>bool</code> <p>False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     status = conn.get_tracking()\n...     if status.is_leap_pending():\n...         print(f\"Leap second pending: {status.leap_status.name}\")\n</code></pre> Source code in <code>src/pychrony/models.py</code> <pre><code>def is_leap_pending(self) -&gt; bool:\n    \"\"\"Check if a leap second adjustment is pending.\n\n    Returns:\n        True if leap_status is INSERT or DELETE,\n        False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     status = conn.get_tracking()\n        ...     if status.is_leap_pending():\n        ...         print(f\"Leap second pending: {status.leap_status.name}\")\n    \"\"\"\n    return self.leap_status in (LeapStatus.INSERT, LeapStatus.DELETE)\n</code></pre>"},{"location":"api/#pychrony.Source","title":"<code>Source</code>  <code>dataclass</code>","text":"<p>Chrony source information.</p> <p>Represents an NTP server, peer, or reference clock being used as a time source by chronyd.</p> <p>Attributes:</p> Name Type Description <code>address</code> <code>str</code> <p>IP address or reference ID of the source (IPv4, IPv6, or refclock ID).</p> <code>poll</code> <code>int</code> <p>Polling interval as log2 seconds (e.g., 6 means 64 seconds).</p> <code>stratum</code> <code>int</code> <p>NTP stratum level of the source (0-15).</p> <code>state</code> <code>SourceState</code> <p>Selection state (see <code>SourceState</code>).</p> <code>mode</code> <code>SourceMode</code> <p>Source mode (see <code>SourceMode</code>).</p> <code>flags</code> <code>int</code> <p>Source flags (bitfield).</p> <code>reachability</code> <code>int</code> <p>Reachability register (8-bit, 377 octal = all recent polls succeeded).</p> <code>last_sample_ago</code> <code>int</code> <p>Seconds since last valid sample was received.</p> <code>orig_latest_meas</code> <code>float</code> <p>Original last sample offset (seconds).</p> <code>latest_meas</code> <code>float</code> <p>Adjusted last sample offset (seconds).</p> <code>latest_meas_err</code> <code>float</code> <p>Last sample error bound (seconds).</p> See Also <p><code>SourceState</code>: Enum for source selection states. <code>SourceMode</code>: Enum for source operational modes. <code>ChronyConnection.get_sources</code>: Method to retrieve source list.</p> Source code in <code>src/pychrony/models.py</code> <pre><code>@dataclass(frozen=True)\nclass Source:\n    \"\"\"Chrony source information.\n\n    Represents an NTP server, peer, or reference clock being used\n    as a time source by chronyd.\n\n    Attributes:\n        address: IP address or reference ID of the source (IPv4, IPv6, or refclock ID).\n        poll: Polling interval as log2 seconds (e.g., 6 means 64 seconds).\n        stratum: NTP stratum level of the source (0-15).\n        state: Selection state (see `SourceState`).\n        mode: Source mode (see `SourceMode`).\n        flags: Source flags (bitfield).\n        reachability: Reachability register (8-bit, 377 octal = all recent polls succeeded).\n        last_sample_ago: Seconds since last valid sample was received.\n        orig_latest_meas: Original last sample offset (seconds).\n        latest_meas: Adjusted last sample offset (seconds).\n        latest_meas_err: Last sample error bound (seconds).\n\n    See Also:\n        `SourceState`: Enum for source selection states.\n        `SourceMode`: Enum for source operational modes.\n        `ChronyConnection.get_sources`: Method to retrieve source list.\n    \"\"\"\n\n    address: str\n    poll: int\n    stratum: int\n    state: SourceState\n    mode: SourceMode\n    flags: int\n    reachability: int\n    last_sample_ago: int\n    orig_latest_meas: float\n    latest_meas: float\n    latest_meas_err: float\n\n    def is_reachable(self) -&gt; bool:\n        \"\"\"Check if the source has been reachable recently.\n\n        Returns:\n            True if reachability register is non-zero (at least one successful poll).\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     for src in conn.get_sources():\n            ...         if not src.is_reachable():\n            ...             print(f\"Source {src.address} is unreachable\")\n        \"\"\"\n        return self.reachability &gt; 0\n\n    def is_selected(self) -&gt; bool:\n        \"\"\"Check if this source is currently selected for synchronization.\n\n        Returns:\n            True if state is SELECTED.\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     for src in conn.get_sources():\n            ...         if src.is_selected():\n            ...             print(f\"Currently using {src.address}\")\n        \"\"\"\n        return self.state == SourceState.SELECTED\n</code></pre>"},{"location":"api/#pychrony.Source.is_reachable","title":"<code>is_reachable()</code>","text":"<p>Check if the source has been reachable recently.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if reachability register is non-zero (at least one successful poll).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     for src in conn.get_sources():\n...         if not src.is_reachable():\n...             print(f\"Source {src.address} is unreachable\")\n</code></pre> Source code in <code>src/pychrony/models.py</code> <pre><code>def is_reachable(self) -&gt; bool:\n    \"\"\"Check if the source has been reachable recently.\n\n    Returns:\n        True if reachability register is non-zero (at least one successful poll).\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     for src in conn.get_sources():\n        ...         if not src.is_reachable():\n        ...             print(f\"Source {src.address} is unreachable\")\n    \"\"\"\n    return self.reachability &gt; 0\n</code></pre>"},{"location":"api/#pychrony.Source.is_selected","title":"<code>is_selected()</code>","text":"<p>Check if this source is currently selected for synchronization.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if state is SELECTED.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     for src in conn.get_sources():\n...         if src.is_selected():\n...             print(f\"Currently using {src.address}\")\n</code></pre> Source code in <code>src/pychrony/models.py</code> <pre><code>def is_selected(self) -&gt; bool:\n    \"\"\"Check if this source is currently selected for synchronization.\n\n    Returns:\n        True if state is SELECTED.\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     for src in conn.get_sources():\n        ...         if src.is_selected():\n        ...             print(f\"Currently using {src.address}\")\n    \"\"\"\n    return self.state == SourceState.SELECTED\n</code></pre>"},{"location":"api/#pychrony.SourceStats","title":"<code>SourceStats</code>  <code>dataclass</code>","text":"<p>Chrony source statistics.</p> <p>Represents statistical data about measurements from an NTP source, used for drift and offset estimation.</p> <p>Attributes:</p> Name Type Description <code>reference_id</code> <code>int</code> <p>32-bit NTP reference identifier.</p> <code>address</code> <code>str</code> <p>IP address of the source (empty for reference clocks).</p> <code>samples</code> <code>int</code> <p>Number of sample points currently retained.</p> <code>runs</code> <code>int</code> <p>Number of runs of residuals with same sign.</p> <code>span</code> <code>int</code> <p>Time interval between oldest and newest samples (seconds).</p> <code>std_dev</code> <code>float</code> <p>Estimated sample standard deviation (seconds).</p> <code>resid_freq</code> <code>float</code> <p>Residual frequency (parts per million).</p> <code>skew</code> <code>float</code> <p>Frequency skew (error bound) in ppm.</p> <code>offset</code> <code>float</code> <p>Estimated offset of the source (seconds).</p> <code>offset_err</code> <code>float</code> <p>Offset error bound (seconds).</p> See Also <p><code>ChronyConnection.get_source_stats</code>: Method to retrieve statistics.</p> Source code in <code>src/pychrony/models.py</code> <pre><code>@dataclass(frozen=True)\nclass SourceStats:\n    \"\"\"Chrony source statistics.\n\n    Represents statistical data about measurements from an NTP source,\n    used for drift and offset estimation.\n\n    Attributes:\n        reference_id: 32-bit NTP reference identifier.\n        address: IP address of the source (empty for reference clocks).\n        samples: Number of sample points currently retained.\n        runs: Number of runs of residuals with same sign.\n        span: Time interval between oldest and newest samples (seconds).\n        std_dev: Estimated sample standard deviation (seconds).\n        resid_freq: Residual frequency (parts per million).\n        skew: Frequency skew (error bound) in ppm.\n        offset: Estimated offset of the source (seconds).\n        offset_err: Offset error bound (seconds).\n\n    See Also:\n        `ChronyConnection.get_source_stats`: Method to retrieve statistics.\n    \"\"\"\n\n    reference_id: int\n    address: str\n    samples: int\n    runs: int\n    span: int\n    std_dev: float\n    resid_freq: float\n    skew: float\n    offset: float\n    offset_err: float\n\n    def has_sufficient_samples(self, minimum: int = 4) -&gt; bool:\n        \"\"\"Check if enough samples exist for reliable statistics.\n\n        Args:\n            minimum: Minimum number of samples required (default 4).\n\n        Returns:\n            True if samples &gt;= minimum.\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     for stats in conn.get_source_stats():\n            ...         if stats.has_sufficient_samples(8):\n            ...             print(f\"{stats.address}: offset={stats.offset:.6f}s\")\n        \"\"\"\n        return self.samples &gt;= minimum\n</code></pre>"},{"location":"api/#pychrony.SourceStats.has_sufficient_samples","title":"<code>has_sufficient_samples(minimum=4)</code>","text":"<p>Check if enough samples exist for reliable statistics.</p> <p>Parameters:</p> Name Type Description Default <code>minimum</code> <code>int</code> <p>Minimum number of samples required (default 4).</p> <code>4</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if samples &gt;= minimum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     for stats in conn.get_source_stats():\n...         if stats.has_sufficient_samples(8):\n...             print(f\"{stats.address}: offset={stats.offset:.6f}s\")\n</code></pre> Source code in <code>src/pychrony/models.py</code> <pre><code>def has_sufficient_samples(self, minimum: int = 4) -&gt; bool:\n    \"\"\"Check if enough samples exist for reliable statistics.\n\n    Args:\n        minimum: Minimum number of samples required (default 4).\n\n    Returns:\n        True if samples &gt;= minimum.\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     for stats in conn.get_source_stats():\n        ...         if stats.has_sufficient_samples(8):\n        ...             print(f\"{stats.address}: offset={stats.offset:.6f}s\")\n    \"\"\"\n    return self.samples &gt;= minimum\n</code></pre>"},{"location":"api/#pychrony.RTCData","title":"<code>RTCData</code>  <code>dataclass</code>","text":"<p>Chrony RTC (Real-Time Clock) data.</p> <p>Represents information about the hardware RTC and its relationship to system time, as tracked by chronyd.</p> <p>Note: RTC tracking must be enabled in chronyd configuration. If not enabled, <code>get_rtc_data()</code> returns <code>None</code>.</p> <p>Attributes:</p> Name Type Description <code>ref_time</code> <code>float</code> <p>RTC reading at last error measurement (seconds since epoch).</p> <code>samples</code> <code>int</code> <p>Number of previous measurements used for calibration.</p> <code>runs</code> <code>int</code> <p>Number of runs of residuals (indicates linear model fit quality).</p> <code>span</code> <code>int</code> <p>Time period covered by measurements (seconds).</p> <code>offset</code> <code>float</code> <p>Estimated RTC offset (fast by) in seconds.</p> <code>freq_offset</code> <code>float</code> <p>RTC frequency offset (drift rate) in parts per million.</p> See Also <p><code>ChronyConnection.get_rtc_data</code>: Method to retrieve RTC data.</p> Source code in <code>src/pychrony/models.py</code> <pre><code>@dataclass(frozen=True)\nclass RTCData:\n    \"\"\"Chrony RTC (Real-Time Clock) data.\n\n    Represents information about the hardware RTC and its relationship\n    to system time, as tracked by chronyd.\n\n    Note: RTC tracking must be enabled in chronyd configuration.\n    If not enabled, `get_rtc_data()` returns ``None``.\n\n    Attributes:\n        ref_time: RTC reading at last error measurement (seconds since epoch).\n        samples: Number of previous measurements used for calibration.\n        runs: Number of runs of residuals (indicates linear model fit quality).\n        span: Time period covered by measurements (seconds).\n        offset: Estimated RTC offset (fast by) in seconds.\n        freq_offset: RTC frequency offset (drift rate) in parts per million.\n\n    See Also:\n        `ChronyConnection.get_rtc_data`: Method to retrieve RTC data.\n    \"\"\"\n\n    ref_time: float\n    samples: int\n    runs: int\n    span: int\n    offset: float\n    freq_offset: float\n\n    def is_calibrated(self) -&gt; bool:\n        \"\"\"Check if RTC has enough calibration data.\n\n        Returns:\n            True if samples &gt; 0 (some calibration exists).\n\n        Examples:\n            &gt;&gt;&gt; with ChronyConnection() as conn:\n            ...     rtc = conn.get_rtc_data()\n            ...     if rtc and rtc.is_calibrated():\n            ...         print(f\"RTC drift: {rtc.freq_offset:.2f} ppm\")\n        \"\"\"\n        return self.samples &gt; 0\n</code></pre>"},{"location":"api/#pychrony.RTCData.is_calibrated","title":"<code>is_calibrated()</code>","text":"<p>Check if RTC has enough calibration data.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if samples &gt; 0 (some calibration exists).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with ChronyConnection() as conn:\n...     rtc = conn.get_rtc_data()\n...     if rtc and rtc.is_calibrated():\n...         print(f\"RTC drift: {rtc.freq_offset:.2f} ppm\")\n</code></pre> Source code in <code>src/pychrony/models.py</code> <pre><code>def is_calibrated(self) -&gt; bool:\n    \"\"\"Check if RTC has enough calibration data.\n\n    Returns:\n        True if samples &gt; 0 (some calibration exists).\n\n    Examples:\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     rtc = conn.get_rtc_data()\n        ...     if rtc and rtc.is_calibrated():\n        ...         print(f\"RTC drift: {rtc.freq_offset:.2f} ppm\")\n    \"\"\"\n    return self.samples &gt; 0\n</code></pre>"},{"location":"api/#enums","title":"Enums","text":"<p>Categorical values for status fields.</p>"},{"location":"api/#pychrony.LeapStatus","title":"<code>LeapStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Leap second status for NTP synchronization.</p> <p>Indicates whether time is normal or if a leap second adjustment is scheduled at the next midnight UTC.</p> <p>Attributes:</p> Name Type Description <code>NORMAL</code> <p>No leap second pending.</p> <code>INSERT</code> <p>Leap second will be inserted at midnight (23:59:60).</p> <code>DELETE</code> <p>Leap second will be deleted at midnight (skip 23:59:59).</p> <code>UNSYNC</code> <p>Clock is unsynchronized.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pychrony import ChronyConnection, LeapStatus\n&gt;&gt;&gt; with ChronyConnection() as conn:\n...     status = conn.get_tracking()\n...     if status.leap_status == LeapStatus.INSERT:\n...         print(\"Leap second insertion scheduled\")\n...     elif status.leap_status == LeapStatus.UNSYNC:\n...         print(\"Clock not synchronized\")\n</code></pre> Source code in <code>src/pychrony/models.py</code> <pre><code>class LeapStatus(Enum):\n    \"\"\"Leap second status for NTP synchronization.\n\n    Indicates whether time is normal or if a leap second adjustment\n    is scheduled at the next midnight UTC.\n\n    Attributes:\n        NORMAL: No leap second pending.\n        INSERT: Leap second will be inserted at midnight (23:59:60).\n        DELETE: Leap second will be deleted at midnight (skip 23:59:59).\n        UNSYNC: Clock is unsynchronized.\n\n    Examples:\n        &gt;&gt;&gt; from pychrony import ChronyConnection, LeapStatus\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     status = conn.get_tracking()\n        ...     if status.leap_status == LeapStatus.INSERT:\n        ...         print(\"Leap second insertion scheduled\")\n        ...     elif status.leap_status == LeapStatus.UNSYNC:\n        ...         print(\"Clock not synchronized\")\n    \"\"\"\n\n    NORMAL = 0\n    INSERT = 1\n    DELETE = 2\n    UNSYNC = 3\n</code></pre>"},{"location":"api/#pychrony.SourceState","title":"<code>SourceState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Selection state of a chrony time source.</p> <p>Indicates whether chrony has selected, rejected, or is considering this source for time synchronization.</p> <p>Attributes:</p> Name Type Description <code>SELECTED</code> <p>Currently selected for synchronization.</p> <code>NONSELECTABLE</code> <p>Cannot be selected (bad measurements).</p> <code>FALSETICKER</code> <p>Detected as providing incorrect time.</p> <code>JITTERY</code> <p>Measurements have excessive jitter.</p> <code>UNSELECTED</code> <p>Valid but not currently selected.</p> <code>SELECTABLE</code> <p>Candidate for selection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pychrony import ChronyConnection, SourceState\n&gt;&gt;&gt; with ChronyConnection() as conn:\n...     for src in conn.get_sources():\n...         if src.state == SourceState.FALSETICKER:\n...             print(f\"Warning: {src.address} detected as falseticker\")\n...         elif src.state == SourceState.SELECTED:\n...             print(f\"Active source: {src.address}\")\n</code></pre> Source code in <code>src/pychrony/models.py</code> <pre><code>class SourceState(Enum):\n    \"\"\"Selection state of a chrony time source.\n\n    Indicates whether chrony has selected, rejected, or is\n    considering this source for time synchronization.\n\n    Attributes:\n        SELECTED: Currently selected for synchronization.\n        NONSELECTABLE: Cannot be selected (bad measurements).\n        FALSETICKER: Detected as providing incorrect time.\n        JITTERY: Measurements have excessive jitter.\n        UNSELECTED: Valid but not currently selected.\n        SELECTABLE: Candidate for selection.\n\n    Examples:\n        &gt;&gt;&gt; from pychrony import ChronyConnection, SourceState\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     for src in conn.get_sources():\n        ...         if src.state == SourceState.FALSETICKER:\n        ...             print(f\"Warning: {src.address} detected as falseticker\")\n        ...         elif src.state == SourceState.SELECTED:\n        ...             print(f\"Active source: {src.address}\")\n    \"\"\"\n\n    SELECTED = 0\n    NONSELECTABLE = 1\n    FALSETICKER = 2\n    JITTERY = 3\n    UNSELECTED = 4\n    SELECTABLE = 5\n</code></pre>"},{"location":"api/#pychrony.SourceMode","title":"<code>SourceMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Operational mode of a chrony time source.</p> <p>Distinguishes between NTP client connections, peer relationships, and local reference clocks.</p> <p>Attributes:</p> Name Type Description <code>CLIENT</code> <p>NTP client polling a server.</p> <code>PEER</code> <p>NTP peer relationship (bidirectional).</p> <code>REFCLOCK</code> <p>Local reference clock (GPS, PPS, etc.).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pychrony import ChronyConnection, SourceMode\n&gt;&gt;&gt; with ChronyConnection() as conn:\n...     for src in conn.get_sources():\n...         if src.mode == SourceMode.REFCLOCK:\n...             print(f\"Reference clock: {src.address}\")\n...         elif src.mode == SourceMode.CLIENT:\n...             print(f\"NTP server: {src.address}\")\n</code></pre> Source code in <code>src/pychrony/models.py</code> <pre><code>class SourceMode(Enum):\n    \"\"\"Operational mode of a chrony time source.\n\n    Distinguishes between NTP client connections, peer\n    relationships, and local reference clocks.\n\n    Attributes:\n        CLIENT: NTP client polling a server.\n        PEER: NTP peer relationship (bidirectional).\n        REFCLOCK: Local reference clock (GPS, PPS, etc.).\n\n    Examples:\n        &gt;&gt;&gt; from pychrony import ChronyConnection, SourceMode\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     for src in conn.get_sources():\n        ...         if src.mode == SourceMode.REFCLOCK:\n        ...             print(f\"Reference clock: {src.address}\")\n        ...         elif src.mode == SourceMode.CLIENT:\n        ...             print(f\"NTP server: {src.address}\")\n    \"\"\"\n\n    CLIENT = 0\n    PEER = 1\n    REFCLOCK = 2\n</code></pre>"},{"location":"api/#exceptions","title":"Exceptions","text":"<p>Exception hierarchy for error handling.</p>"},{"location":"api/#pychrony.ChronyError","title":"<code>ChronyError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all chrony-related errors.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>Human-readable error description</p> <code>error_code</code> <p>Optional numeric error code from libchrony</p> Source code in <code>src/pychrony/exceptions.py</code> <pre><code>class ChronyError(Exception):\n    \"\"\"Base exception for all chrony-related errors.\n\n    Attributes:\n        message: Human-readable error description\n        error_code: Optional numeric error code from libchrony\n    \"\"\"\n\n    def __init__(self, message: str, error_code: Optional[int] = None):\n        super().__init__(message)\n        self.message = message\n        self.error_code = error_code\n\n    def __str__(self) -&gt; str:\n        if self.error_code is not None:\n            return f\"{self.message} (error code: {self.error_code})\"\n        return self.message\n</code></pre>"},{"location":"api/#pychrony.ChronyConnectionError","title":"<code>ChronyConnectionError</code>","text":"<p>               Bases: <code>ChronyError</code></p> <p>Raised when connection to chronyd fails.</p> <p>Common causes:</p> <ul> <li>chronyd is not running</li> <li>Socket path does not exist</li> <li><code>chrony_open_socket()</code> returns &lt; 0</li> <li><code>chrony_init_session()</code> returns error</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pychrony import ChronyConnection, ChronyConnectionError\n&gt;&gt;&gt; try:\n...     with ChronyConnection() as conn:\n...         status = conn.get_tracking()\n... except ChronyConnectionError as e:\n...     print(f\"Connection failed: {e}\")\n</code></pre> Source code in <code>src/pychrony/exceptions.py</code> <pre><code>class ChronyConnectionError(ChronyError):\n    \"\"\"Raised when connection to chronyd fails.\n\n    Common causes:\n\n    - chronyd is not running\n    - Socket path does not exist\n    - ``chrony_open_socket()`` returns &lt; 0\n    - ``chrony_init_session()`` returns error\n\n    Examples:\n        &gt;&gt;&gt; from pychrony import ChronyConnection, ChronyConnectionError\n        &gt;&gt;&gt; try:\n        ...     with ChronyConnection() as conn:\n        ...         status = conn.get_tracking()\n        ... except ChronyConnectionError as e:\n        ...     print(f\"Connection failed: {e}\")\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#pychrony.ChronyPermissionError","title":"<code>ChronyPermissionError</code>","text":"<p>               Bases: <code>ChronyError</code></p> <p>Raised when access to chronyd is denied.</p> <p>Common causes:</p> <ul> <li>User not in chrony group</li> <li>Running as unprivileged user</li> <li>SELinux/AppArmor restrictions</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pychrony import ChronyConnection, ChronyPermissionError\n&gt;&gt;&gt; try:\n...     with ChronyConnection() as conn:\n...         status = conn.get_tracking()\n... except ChronyPermissionError as e:\n...     print(f\"Permission denied: {e}\")\n...     print(\"Add user to chrony group or run as root\")\n</code></pre> Source code in <code>src/pychrony/exceptions.py</code> <pre><code>class ChronyPermissionError(ChronyError):\n    \"\"\"Raised when access to chronyd is denied.\n\n    Common causes:\n\n    - User not in chrony group\n    - Running as unprivileged user\n    - SELinux/AppArmor restrictions\n\n    Examples:\n        &gt;&gt;&gt; from pychrony import ChronyConnection, ChronyPermissionError\n        &gt;&gt;&gt; try:\n        ...     with ChronyConnection() as conn:\n        ...         status = conn.get_tracking()\n        ... except ChronyPermissionError as e:\n        ...     print(f\"Permission denied: {e}\")\n        ...     print(\"Add user to chrony group or run as root\")\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#pychrony.ChronyDataError","title":"<code>ChronyDataError</code>","text":"<p>               Bases: <code>ChronyError</code></p> <p>Raised when tracking data is invalid or incomplete.</p> <p>Common causes:</p> <ul> <li><code>chrony_get_field_index()</code> returns &lt; 0 (field not found)</li> <li><code>chrony_process_response()</code> returns error</li> <li>Field validation fails (NaN, out of range)</li> <li>Protocol version mismatch</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pychrony import ChronyConnection, ChronyDataError\n&gt;&gt;&gt; with ChronyConnection() as conn:\n...     try:\n...         status = conn.get_tracking()\n...     except ChronyDataError as e:\n...         print(f\"Invalid data: {e}\")\n</code></pre> Source code in <code>src/pychrony/exceptions.py</code> <pre><code>class ChronyDataError(ChronyError):\n    \"\"\"Raised when tracking data is invalid or incomplete.\n\n    Common causes:\n\n    - ``chrony_get_field_index()`` returns &lt; 0 (field not found)\n    - ``chrony_process_response()`` returns error\n    - Field validation fails (NaN, out of range)\n    - Protocol version mismatch\n\n    Examples:\n        &gt;&gt;&gt; from pychrony import ChronyConnection, ChronyDataError\n        &gt;&gt;&gt; with ChronyConnection() as conn:\n        ...     try:\n        ...         status = conn.get_tracking()\n        ...     except ChronyDataError as e:\n        ...         print(f\"Invalid data: {e}\")\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#pychrony.ChronyLibraryError","title":"<code>ChronyLibraryError</code>","text":"<p>               Bases: <code>ChronyError</code></p> <p>Raised when libchrony is not available.</p> <p>Common causes:</p> <ul> <li>libchrony not installed at runtime</li> <li>CFFI bindings not compiled (missing libchrony-devel at build time)</li> <li>Library version incompatible</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pychrony import ChronyConnection, ChronyLibraryError\n&gt;&gt;&gt; try:\n...     with ChronyConnection() as conn:\n...         status = conn.get_tracking()\n... except ChronyLibraryError as e:\n...     print(f\"Library not available: {e}\")\n...     print(\"Install libchrony-devel and rebuild\")\n</code></pre> Source code in <code>src/pychrony/exceptions.py</code> <pre><code>class ChronyLibraryError(ChronyError):\n    \"\"\"Raised when libchrony is not available.\n\n    Common causes:\n\n    - libchrony not installed at runtime\n    - CFFI bindings not compiled (missing libchrony-devel at build time)\n    - Library version incompatible\n\n    Examples:\n        &gt;&gt;&gt; from pychrony import ChronyConnection, ChronyLibraryError\n        &gt;&gt;&gt; try:\n        ...     with ChronyConnection() as conn:\n        ...         status = conn.get_tracking()\n        ... except ChronyLibraryError as e:\n        ...     print(f\"Library not available: {e}\")\n        ...     print(\"Install libchrony-devel and rebuild\")\n    \"\"\"\n\n    def __init__(self, message: str):\n        super().__init__(message, error_code=None)\n</code></pre>"},{"location":"api/#testing-utilities","title":"Testing Utilities","text":"<p>Factory functions and pytest fixtures for testing code that uses pychrony.</p>"},{"location":"api/#pychrony.testing","title":"<code>testing</code>","text":"<p>Testing utilities for pychrony.</p> <p>This module provides factory functions and pytest fixtures for creating test instances of pychrony dataclasses with sensible defaults.</p> <p>Factory Functions (for any test framework):     from pychrony.testing import make_tracking, make_source     status = make_tracking(stratum=3, offset=-0.001)</p> <p>Pytest Fixtures (auto-discovered via plugin):     def test_something(tracking_status, source):         assert tracking_status.is_synchronized()</p>"},{"location":"api/#pychrony.testing.make_tracking","title":"<code>make_tracking(**overrides)</code>","text":"<p>Create a TrackingStatus instance with sensible defaults.</p> <p>Default state is synchronized (reference_id != 0, stratum=2).</p> <p>Parameters:</p> Name Type Description Default <code>**overrides</code> <code>Any</code> <p>Field values to override defaults</p> <code>{}</code> <p>Returns:</p> Type Description <code>TrackingStatus</code> <p>TrackingStatus instance</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; make_tracking()  # Synchronized status\n&gt;&gt;&gt; make_tracking(stratum=16, reference_id=0)  # Unsynchronized\n&gt;&gt;&gt; make_tracking(leap_status=LeapStatus.INSERT)  # Leap pending\n</code></pre> Source code in <code>src/pychrony/testing.py</code> <pre><code>def make_tracking(**overrides: Any) -&gt; TrackingStatus:\n    \"\"\"Create a TrackingStatus instance with sensible defaults.\n\n    Default state is synchronized (reference_id != 0, stratum=2).\n\n    Args:\n        **overrides: Field values to override defaults\n\n    Returns:\n        TrackingStatus instance\n\n    Examples:\n        &gt;&gt;&gt; make_tracking()  # Synchronized status\n        &gt;&gt;&gt; make_tracking(stratum=16, reference_id=0)  # Unsynchronized\n        &gt;&gt;&gt; make_tracking(leap_status=LeapStatus.INSERT)  # Leap pending\n    \"\"\"\n    return TrackingStatus(**{**TRACKING_DEFAULTS, **overrides})\n</code></pre>"},{"location":"api/#pychrony.testing.make_source","title":"<code>make_source(**overrides)</code>","text":"<p>Create a Source instance with sensible defaults.</p> <p>Default state is selected and reachable.</p> <p>Parameters:</p> Name Type Description Default <code>**overrides</code> <code>Any</code> <p>Field values to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Source</code> <p>Source instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; make_source()  # Selected, reachable source\n&gt;&gt;&gt; make_source(state=SourceState.FALSETICKER)  # Falseticker\n&gt;&gt;&gt; make_source(reachability=0)  # Unreachable source\n</code></pre> Source code in <code>src/pychrony/testing.py</code> <pre><code>def make_source(**overrides: Any) -&gt; Source:\n    \"\"\"Create a Source instance with sensible defaults.\n\n    Default state is selected and reachable.\n\n    Args:\n        **overrides: Field values to override defaults.\n\n    Returns:\n        Source instance.\n\n    Examples:\n        &gt;&gt;&gt; make_source()  # Selected, reachable source\n        &gt;&gt;&gt; make_source(state=SourceState.FALSETICKER)  # Falseticker\n        &gt;&gt;&gt; make_source(reachability=0)  # Unreachable source\n    \"\"\"\n    return Source(**{**SOURCE_DEFAULTS, **overrides})\n</code></pre>"},{"location":"api/#pychrony.testing.make_source_stats","title":"<code>make_source_stats(**overrides)</code>","text":"<p>Create a SourceStats instance with sensible defaults.</p> <p>Default has 8 samples (sufficient for statistics).</p> <p>Parameters:</p> Name Type Description Default <code>**overrides</code> <code>Any</code> <p>Field values to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>SourceStats</code> <p>SourceStats instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; make_source_stats()  # Stats with 8 samples\n&gt;&gt;&gt; make_source_stats(samples=2)  # Insufficient samples\n&gt;&gt;&gt; make_source_stats(offset=0.001)  # Custom offset\n</code></pre> Source code in <code>src/pychrony/testing.py</code> <pre><code>def make_source_stats(**overrides: Any) -&gt; SourceStats:\n    \"\"\"Create a SourceStats instance with sensible defaults.\n\n    Default has 8 samples (sufficient for statistics).\n\n    Args:\n        **overrides: Field values to override defaults.\n\n    Returns:\n        SourceStats instance.\n\n    Examples:\n        &gt;&gt;&gt; make_source_stats()  # Stats with 8 samples\n        &gt;&gt;&gt; make_source_stats(samples=2)  # Insufficient samples\n        &gt;&gt;&gt; make_source_stats(offset=0.001)  # Custom offset\n    \"\"\"\n    return SourceStats(**{**SOURCESTATS_DEFAULTS, **overrides})\n</code></pre>"},{"location":"api/#pychrony.testing.make_rtc_data","title":"<code>make_rtc_data(**overrides)</code>","text":"<p>Create an RTCData instance with sensible defaults.</p> <p>Default is calibrated (samples &gt; 0).</p> <p>Parameters:</p> Name Type Description Default <code>**overrides</code> <code>Any</code> <p>Field values to override defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>RTCData</code> <p>RTCData instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; make_rtc_data()  # Calibrated RTC\n&gt;&gt;&gt; make_rtc_data(samples=0)  # Uncalibrated RTC\n&gt;&gt;&gt; make_rtc_data(freq_offset=-5.0)  # Custom drift rate\n</code></pre> Source code in <code>src/pychrony/testing.py</code> <pre><code>def make_rtc_data(**overrides: Any) -&gt; RTCData:\n    \"\"\"Create an RTCData instance with sensible defaults.\n\n    Default is calibrated (samples &gt; 0).\n\n    Args:\n        **overrides: Field values to override defaults.\n\n    Returns:\n        RTCData instance.\n\n    Examples:\n        &gt;&gt;&gt; make_rtc_data()  # Calibrated RTC\n        &gt;&gt;&gt; make_rtc_data(samples=0)  # Uncalibrated RTC\n        &gt;&gt;&gt; make_rtc_data(freq_offset=-5.0)  # Custom drift rate\n    \"\"\"\n    return RTCData(**{**RTCDATA_DEFAULTS, **overrides})\n</code></pre>"},{"location":"api/#pychrony.testing.tracking_status","title":"<code>tracking_status()</code>","text":"<p>Fixture providing a synchronized TrackingStatus with defaults.</p> Source code in <code>src/pychrony/testing.py</code> <pre><code>@pytest.fixture\ndef tracking_status() -&gt; TrackingStatus:\n    \"\"\"Fixture providing a synchronized TrackingStatus with defaults.\"\"\"\n    return make_tracking()\n</code></pre>"},{"location":"api/#pychrony.testing.source","title":"<code>source()</code>","text":"<p>Fixture providing a selected, reachable Source with defaults.</p> Source code in <code>src/pychrony/testing.py</code> <pre><code>@pytest.fixture\ndef source() -&gt; Source:\n    \"\"\"Fixture providing a selected, reachable Source with defaults.\"\"\"\n    return make_source()\n</code></pre>"},{"location":"api/#pychrony.testing.source_stats","title":"<code>source_stats()</code>","text":"<p>Fixture providing a SourceStats with sufficient samples.</p> Source code in <code>src/pychrony/testing.py</code> <pre><code>@pytest.fixture\ndef source_stats() -&gt; SourceStats:\n    \"\"\"Fixture providing a SourceStats with sufficient samples.\"\"\"\n    return make_source_stats()\n</code></pre>"},{"location":"api/#pychrony.testing.rtc_data","title":"<code>rtc_data()</code>","text":"<p>Fixture providing a calibrated RTCData with defaults.</p> Source code in <code>src/pychrony/testing.py</code> <pre><code>@pytest.fixture\ndef rtc_data() -&gt; RTCData:\n    \"\"\"Fixture providing a calibrated RTCData with defaults.\"\"\"\n    return make_rtc_data()\n</code></pre>"}]}